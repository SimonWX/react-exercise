https://www.jianshu.com/p/7ea01a3beb7a

1、手写一个js的深克隆 （美团，爱奇艺）
function deepCopy(obj){
	// 判断是否是简单数据类型
	if(typeof obj == 'object'){
		// 复杂数据类型
		var result = obj.constructor == Array ? [] ： {};
		for (let i in obj){
			result[i] = typeof obj[i] == 'object' ? deepCopy(obj[i]) : obj[i];
		}	
	}else{
		// 简单数据类型 直接 == 赋值
		var  result = obj;
	}
	return result;
}

2、手写组合继承(美团，爱奇艺，搜狗)
// 定义一个动物类
function Animal (name){
	// 属性
	this.name = name || 'Animal';
	//实例方法
	this.sleep = function(){
		console.log(this.name + '正在睡觉! ');
	}
}
// 原型方法
Animal.prototype.eat = function(food){
	console.log(this.name + '正在吃：' + food);
}
// 组合继承
funciton Cat（name）{
	Animal.call(this);
	this.name = name || 'Tom';
}
Cat.prototype = new Animal();

手写一个Promise（爱奇艺，搜狐）
// promise是一个构造函数，下面是一个简单实例
var promise = new Promise((resolve,reject)=>{
	if(操作成功){
		resolve(value)
	}else{
		reject(error)
	}
})
promise.then(function (value){
	//success
},function(value){
	// failure
})

3、防抖和节流
scroll事件本身会触发页面的重新渲染，同时scroll事件的handler又会被高频度的触发，因此事件的handler内部不应该有复杂操作，例如DOM操作就不应该放在事件处理中
针对此类高频度触发事件的问题(例如页面scroll，屏幕resize, 监听用户输入等), 有两种常用的解决方法，防抖和节流

（1）防抖(Debouncing)
防抖技术既是可以把多个顺序地调用合并成一次，也就是在一定时间内，规定事件会被触发的次数
通俗一点来说，先看下面这个简化的例子，这个简单的防抖的例子大概功能就是如果500ms 内没有连续触发两次scroll事件，那么才会触发按我们真正想在scroll事件中触发的函数
// 简单的防抖动函数
function debounce(func, wait, immediate){
	// 定时器变量
	var timeout;
	return function(){
		// 每次触发scroll handler 时先清除定时器
		clearTimeout(timeout);
		// 指定xx ms后触发真正想进行的操作 handler
		timeout = setTimeout(func, wait)
	}
}
// 实际想绑定在scroll事件上的handler
function realFunc(){
	console.log('success');
}
// 采用了防抖动
window.addEventListener('scroll', debounce(realFunc, 500));
// 没采用防抖动
window.addEventListener('scroll', realFunc)

// 完整的防抖动函数：
function debounce(func, wait, immediate){
	var timeout;
	return function(){
		var context = this, args = arguments;
		var later = function(){
			timeout = null;
			if(!immediate) func.apply(context, args);
		};
		var callNow = immediate && !timeout;
		clearTimeout(timeout)
		timeout = setTimeout(later, wait);
		if (callNow) func.apply(context, args);
	}
}
var myEfficientFn = debounce(funcion(){
	// 滚动中的真正的操作
}, 250);
// 绑定监听
window.addEventListener('resize', myEfficientFn);

（2）节流（Throttling）
防抖函数确实不错，但是也存在问题，譬如图片的懒加载，我希望在下滑过程中图片不断的被加载出来，而不是只有当我停止下滑时候，图片才被加载出来。又或者下滑时候的数据的ajax请求加载也是同理。
这个时候，我们希望即使页面在不断被滚动，但是滚动handler也可以以一定的频率被触发(譬如250ms触发一次), 这类场景，就要用到另一种技巧，称为节流函数(throttling)
节流函数，只允许一个函数在X毫秒内执行一次。与防抖相比，节流函数最主要的不同在于它保证在X毫秒内至少执行一次我们希望触发的时间handler。与防抖相比，节流函数多一个mustRun属性，代表mustRun毫秒内，必然会触发一次handler。
同样是利用定时器，看看下面的简单示例，大概功能就是如果在一段时间内scroll触发的间隔一直短于500ms，那么能保证事件我们希望调用的handler至少在1000ms内会触发一次。
// 简单的节流函数
function throttle(func, wait, mustRun){
	var timeout,
		startTime = new Date();

	return function(){
		var context = this,
			args = arguments,
			curTime = new Date();

		clearTimeout(timeout);
		// 如果达到了规定的触发时间间隔，触发handler
		if(curTime - startTime >= mustRun){
			func.apply(context, args);
			startTime = curTime;
		// 没达到触发间隔，重新设定定时器
		}else{
			timeout = setTimeout(func, wait);
		}
	}
}
// 实际想绑定在scroll 事件上的handler
function realFunc(){
	console.log('Success');
}
// 采用了节流函数
window.addEventListener('scroll', throttle(realFunc, 500, 1000))

4.手写原生js实现事件代理，并要求兼容浏览器(腾讯)
// 简单的事件委托
function delegateEvent(interfaceEle, selector, type, fn){
	if(interfaceEle.addEventListener){
		interfaceEle.addEventListener(type, eventfn);
	}else{
		interfaceEle.attachEvent('on'+type, eventfn);
	}
}